/*
 * File: bsp.procgen
 * Author: Roman Dobias
 * Purpose: generate 2D space separation
 * Note: input structure bsp with boundaries
 * Output: bspSpace with collection of areas (both room and halls)
 *
 */
#include "svg.procgen"

/*
 * Algorith - BSP
 * 1. split space into N subspaces and eventually generate bspCollector with single area
 * 2. let bspCollector collect themselfs 
 * 3. finally, get result in bspResult
 */

parameter float BSPRANDOMAMOUNT = 0.4;

using bspArea = struct 
{
    float x1;
    float y1;
    float x2;
    float y2;
};
using bspPoint = struct
{
    float x; 
    float y;
};

using bspLevel = struct
{
    bspArea area;
    int remainingIteration;
};

using bspCollector = struct {
    int level;
    // collection of bspAreas
    collection areas;

    // collection of bspAreas between bspAreas
    collection paths;
};

using bspFinal = struct 
{
    bspCollector finalProduct;
};

// linear interpolation
float lerp(float pointa, float pointb, float p)
{
    return (pointa*(1.0-p) + pointb*p);
}

// get random rectangle inside
bspArea bspGetRandomSubArea(bspArea input)
{
    float newX = lerp(input.x1, input.x2, uniform(0.0,BSPRANDOMAMOUNT));
    float newY = lerp(input.y1, input.y2, uniform(0.0,BSPRANDOMAMOUNT));
    float endX = lerp(newX, input.x2, uniform(1.0-BSPRANDOMAMOUNT,1.0));
    float endY = lerp(newY, input.y2, uniform(1.0-BSPRANDOMAMOUNT,1.0));
    return bspArea(newX, newY, endX, endY);
}

using bspIteration = rule bspLevel
{
    if(this.remainingIteration > 0)
    {
        return true;
    }
    return false;
} {
 
    if(random() < 0.05)
    {
        bspArea finalRectangle = bspGetRandomSubArea(this.area);
        // create collector
        collection area;
        area.insert(finalRectangle);
        collection empty;
        appendSymbol(bspCollector(this.remainingIteration, area, empty));
        return;
    }

  
    float middleX = (this.area.x1 + this.area.x2)*0.5;
    float middleY = (this.area.y1 + this.area.y2)*0.5;
    // randomly choose whether to split vertically or horizontally
    if(random() < 0.5)
    {
        appendSymbol(bspLevel(bspArea(this.area.x1, this.area.y1, middleX, this.area.y2), this.remainingIteration -1));
        appendSymbol(bspLevel(bspArea(middleX, this.area.y1, this.area.x2, this.area.y2), this.remainingIteration -1));
    } else {
        appendSymbol(bspLevel(bspArea(this.area.x1, this.area.y1, this.area.x2, middleY), this.remainingIteration -1));
        appendSymbol(bspLevel(bspArea(this.area.x1, middleY, this.area.x2, this.area.y2), this.remainingIteration -1));
    }
};

using bspConvert = rule bspLevel
{
    if(this.remainingIteration == 0)
    {
        return true;
    }
    return false;
} {

    bspArea finalRectangle = bspGetRandomSubArea(this.area);
    // create collector
    collection area;
    area.insert(finalRectangle);
    collection empty;
    appendSymbol(bspCollector(this.remainingIteration, area, empty));

    // visualise rectangle
    collection STYLE;
    STYLE.insert(fillColorStyle(REDCOLOR));
    //appendSymbol(rectangle(point(finalRectangle.x1, finalRectangle.y1), point(finalRectangle.x2, finalRectangle.y2), STYLE ));
};

bool bspHasCollectorAsNeighboor(int currentID)
{
    if(hasSymbol(getCurrentStringId(), currentID+1))
    {
        any nextSymbol = getSymbol(getCurrentStringId(), currentID+1);
        if(typeid(nextSymbol) == typeid<bspCollector>)
        {
            return true;
        }
    }
    return false;
}


bool bspHasCollectorAsNeighboorWithLevel(int currentID, int level)
{
    if(hasSymbol(getCurrentStringId(), currentID+1))
    {
        any nextSymbol = getSymbol(getCurrentStringId(), currentID+1);
        if(typeid(nextSymbol) == typeid<bspCollector>)
        {
            bspCollector bspNext = convert<bspCollector>(nextSymbol);
            if(bspNext.level == level)
            {
                return true;
            }
        }
    }
    return false;
}

float min(float a, float b)
{
    if(a > b)
    {
        return b;
    }
    return a;
}

float abs(float a)
{
    if(a > 0)
    {
        return a;
    }
    return -a;
}

float distanceBetweenBspAreas(bspArea first, bspArea second)
{
    point a = point((first.x1+first.x2)*0.5, (first.y1+first.y2)*0.5);
    point b = point((second.x1+second.x2)*0.5, (second.y1+second.y2)*0.5);
    point diff = point(a.x - b.x, a.y-b.y);
    return sqrt(diff.x*diff.x, diff.y*diff.y);
}

float isInRange(float left, float right, float test)
{
    return (left < test && right > test && left == test && right == test);
}

float distance2d(float x1, float y1, float x2, float y2)
{
    float diffx = x1 - x2;
    float diffy = y1 - y2;

    return sqrt(diffx*diffy+diffy*diffy);
}

bspPoint bspAreaAveragePoint(bspArea area)
{
    return bspPoint((area.x1+area.x2)*0.5, (area.y1+area.y2)*0.5);
}
collection createPathBetweenAreas(collection first, collection second)
{
    // get two closes areas from both groups
    int firstID = 0;
    int secondID = 0;
    float minDistance = 100000000000000000000000;

    int i = first.size();
    while(i > 0)
    {
        int j = second.size();
        while(j > 0)
        {
            float currentDistance = distanceBetweenBspAreas(convert<bspArea>(first.at(i-1)), convert<bspArea>(second.at(j-1)));
            if(currentDistance < minDistance)
            {
                minDistance = currentDistance;
                firstID = i-1;
                secondID = j-1;
            } 
            j = j -1;
        }
        i = i -1;
    }

    // find two points from these areas which should lay closest
    bspArea firstArea = convert<bspArea>(first.at(firstID));
    bspArea secondArea = convert<bspArea>(second.at(firstID));

    float firstX = firstArea.x1;
    float firstY = firstArea.y1;
    float secondX= secondArea.x1;
    float secondY= secondArea.y1;

    bspPoint avgPoint1 = bspAreaAveragePoint(firstArea);
    bspPoint avgPoint2 = bspAreaAveragePoint(secondArea);

    bspPoint avgPoint = bspPoint((avgPoint1.x+avgPoint2.x)*0.5, (avgPoint1.y+avgPoint2.y)*0.5);

    if(distance2d(firstArea.x1, firstArea.y1, avgPoint.x,avgPoint.y) < distance2d(firstX, firstY, avgPoint.x,avgPoint.y))
    {
        firstX = firstArea.x1;
        firstY = firstArea.y1;
    }
    if(distance2d(firstArea.x1, firstArea.y2, avgPoint.x,avgPoint.y) < distance2d(firstX, firstY, avgPoint.x,avgPoint.y))
    {
        firstX = firstArea.x1;
        firstY = firstArea.y2;
    }
    if(distance2d(firstArea.x2, firstArea.y2, avgPoint.x,avgPoint.y) < distance2d(firstX, firstY, avgPoint.x,avgPoint.y))
    {
        firstX = firstArea.x2;
        firstY = firstArea.y2;
    }
    if(distance2d(firstArea.x2, firstArea.x1, avgPoint.x,avgPoint.y) < distance2d(firstX, firstY, avgPoint.x,avgPoint.y))
    {
        firstX = firstArea.x2;
        firstY = firstArea.x1;
    }

    if(distance2d(secondArea.x1, secondArea.y1, avgPoint.x,avgPoint.y) < distance2d(secondX, secondY, avgPoint.x,avgPoint.y))
    {
        secondX = secondArea.x1;
        secondY = secondArea.y1;
    }
    if(distance2d(secondArea.x1, secondArea.y2, avgPoint.x,avgPoint.y) < distance2d(secondX, secondY, avgPoint.x,avgPoint.y))
    {
        secondX = secondArea.x1;
        secondY = secondArea.y2;
    }
    if(distance2d(secondArea.x2, secondArea.y2, avgPoint.x,avgPoint.y) < distance2d(secondX, secondY, avgPoint.x,avgPoint.y))
    {
        secondX = secondArea.x2;
        secondY = secondArea.y2;
    }
    if(distance2d(secondArea.x2, secondArea.x1, avgPoint.x,avgPoint.y) < distance2d(secondX, secondY, avgPoint.x,avgPoint.y))
    {
        secondX = secondArea.x2;
        secondY = secondArea.x1;
    }





    // create path between those two points
    collection paths;
    paths.insert(bspArea(firstX, firstY, firstX+10.0, secondY+10.0));
    paths.insert(bspArea(firstX+10.0, secondY+10.0, secondX, secondY));
    return paths;

}

using bspCollectinRule = rule bspCollector 
{
    // detect if next symbol is bspCollector and has the same level
    if(bspHasCollectorAsNeighboorWithLevel(getCurrentPosition(),this.level))
    {
        return true;
    } 
    return false;
} {
    // merge this and its neighbour

    bspCollector neigh = convert<bspCollector>(getSymbol(getCurrentStringId(), getCurrentPosition()+1));
   
    int iterator = neigh.areas.size(); 
    // copy to this
    while(iterator > 0)
    {
        this.areas.insert(neigh.areas.at(iterator-1));
        iterator = iterator -1;
    }

    iterator = neigh.paths.size(); 
    // copy to this
    while(iterator > 0)
    {
        this.paths.insert(neigh.paths.at(iterator-1));
        iterator = iterator -1;
    }

    // join sectors
    collection joiningPaths = createPathBetweenAreas(neigh.areas, this.areas);
    iterator = joiningPaths.size(); 
    // copy to this
    while(iterator > 0)
    {
        this.paths.insert(joiningPaths.at(iterator-1));
        iterator = iterator -1;
    }

    this.level = this.level + 1;
    appendSymbol(this);
    skipSymbol();
};

using bspFinalRule = rule bspCollector 
{
    if(bspHasCollectorAsNeighboor(getCurrentPosition()) == false)
    {
        return true;
    }
    return false;
} {
    // append final structure
    appendSymbol(bspFinal(this));
};

using visualize = rule bspFinal
{
    return true;
} 
{
    collection col;
    col.insert(fillColorStyle(REDCOLOR));

    collection colPaths;
    colPaths.insert(fillColorStyle(rgb(0,255,0)));
    int iterator = this.finalProduct.areas.size(); 
    bspArea area;
    while(iterator > 0)
    {
        area = convert<bspArea>(this.finalProduct.areas.at(iterator-1));
        appendSymbol(rectangle(point(area.x1, area.y1), point(area.x2, area.y2),col));
        iterator = iterator -1;
    }

    iterator = this.finalProduct.paths.size(); 
    // copy to this
    while(iterator > 0)
    {
        area = convert<bspArea>(this.finalProduct.paths.at(iterator-1));
        appendSymbol(rectangle(point(area.x1, area.y1), point(area.x2, area.y2),colPaths));
        iterator = iterator -1;
    }

    
};

int init()
{
    appendSymbol(bspLevel(bspArea(0.0,0.0,1024.0,1024.0), 7));
    setRandomSeed(190.0);

    //initSVG();
    
    //collection col;
    //col.insert(fillColorStyle(REDCOLOR));

    //appendSymbol(rectangle(point(0.0,0.0), point(100.0,100.0), col));
}
