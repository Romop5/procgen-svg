/*
 * File: bsp.procgen
 * Author: Roman Dobias
 * Purpose: generate 2D space separation
 * Note: input structure bsp with boundaries
 * Output: bspSpace with collection of areas (both room and halls)
 *
 */
#include "svg.procgen"

/*
 * Algorith - BSP
 * 1. split space into N subspaces and eventually generate bspCollector with single area
 * 2. let bspCollector collect themselfs 
 * 3. finally, get result in bspResult
 */

parameter float BSPRANDOMAMOUNT = 0.6;

using bspArea = struct 
{
    float x1;
    float y1;
    float x2;
    float y2;
};

using bspLevel = struct
{
    bspArea area;
    int remainingIteration;
};

using bspCollector = struct {
    int level;
    // collection of bspAreas
    collection areas;

    // collection of bspAreas between bspAreas
    collection paths;
};

using bspFinal = struct 
{
    bspCollector finalProduct;
};


using bspIteration = rule bspLevel
{
    if(this.remainingIteration > 0)
    {
        return true;
    }
    return false;
} {
    float middleX = (this.area.x1 + this.area.x2)*0.5;
    float middleY = (this.area.y1 + this.area.y2)*0.5;
    // randomly choose whether to split vertically or horizontally
    if(random() < 0.5)
    {
        appendSymbol(bspLevel(bspArea(this.area.x1, this.area.y1, middleX, this.area.y2), this.remainingIteration -1));
        appendSymbol(bspLevel(bspArea(middleX, this.area.y1, this.area.x2, this.area.y2), this.remainingIteration -1));
    } else {
        appendSymbol(bspLevel(bspArea(this.area.x1, this.area.y1, this.area.x2, middleY), this.remainingIteration -1));
        appendSymbol(bspLevel(bspArea(this.area.x1, middleY, this.area.x2, this.area.y2), this.remainingIteration -1));
    }
};

// linear interpolation
float lerp(float pointa, float pointb, float p)
{
    return (pointa*(1.0-p) + pointb*p);
}

// get random rectangle inside
bspArea bspGetRandomSubArea(bspArea input)
{
    float newX = lerp(input.x1, input.x2, uniform(0.0,BSPRANDOMAMOUNT));
    float newY = lerp(input.y1, input.y2, uniform(0.0,BSPRANDOMAMOUNT));
    float endX = lerp(newX, input.x2, uniform(1.0-BSPRANDOMAMOUNT,1.0));
    float endY = lerp(newY, input.y2, uniform(1.0-BSPRANDOMAMOUNT,1.0));
    return bspArea(newX, newY, endX, endY);
}
using bspConvert = rule bspLevel
{
    if(this.remainingIteration == 0)
    {
        return true;
    }
    return false;
} {

    bspArea finalRectangle = bspGetRandomSubArea(this.area);
    // create collector
    collection area;
    area.insert(finalRectangle);
    collection empty;
    appendSymbol(bspCollector(this.remainingIteration, area, empty));

    // visualise rectangle
    collection STYLE;
    STYLE.insert(fillColorStyle(REDCOLOR));
    //appendSymbol(rectangle(point(finalRectangle.x1, finalRectangle.y1), point(finalRectangle.x2, finalRectangle.y2), STYLE ));
};

bool bspHasCollectorAsNeighboor(int currentID)
{
    if(hasSymbol(getCurrentStringId(), currentID+1))
    {
        any nextSymbol = getSymbol(getCurrentStringId(), currentID+1);
        if(typeid(nextSymbol) == typeid<bspCollector>)
        {
            return true;
        }
    }
    return false;
}


bool bspHasCollectorAsNeighboorWithLevel(int currentID, int level)
{
    if(hasSymbol(getCurrentStringId(), currentID+1))
    {
        any nextSymbol = getSymbol(getCurrentStringId(), currentID+1);
        if(typeid(nextSymbol) == typeid<bspCollector>)
        {
            bspCollector bspNext = convert<bspCollector>(nextSymbol);
            if(bspNext.level == level)
            {
                return true;
            }
        }
    }
    return false;
}

float min(float a, float b)
{
    if(a > b)
    {
        return b;
    }
    return a;
}

float abs(float a)
{
    if(a > 0)
    {
        return a;
    }
    return -a;
}

float distanceBetweenBspAreas(bspArea first, bspArea second)
{
    point a = point((first.x1+first.x2)*0.5, (first.y1+first.y2)*0.5);
    point b = point((second.x1+second.x2)*0.5, (second.y1+second.y2)*0.5);
    point diff = point(a.x - b.x, a.y-b.y);
    return sqrt(diff.x*diff.x, diff.y*diff.y);
}

float isInRange(float left, float right, float test)
{
    return (left <= test && right >= test);
}

collection createPathBetweenAreas(collection first, second)
{
    // get two closes areas from both groups
    int firstID = 0;
    int secondID = 0;
    float minDistance = 100000000000000000000000;

    int i = first.size();
    while(i > 0)
    {
        int j = second.size();
        while(j > 0)
        {
            float currentDistance = distanceBetweenBspAreas(convert<bspArea>(first.at(i-1)), convert<bspArea>(second.at(j-1)));
            if(currentDistance < minDistance)
            {
                minDistance = currentDistance;
                firstID = i-1;
                secondID = j-1;
            } 
        }
    }

    // create path between these rectangles
    bspArea firstArea = convert<bspArea>(first.at(firstId));
    bspArea secondArea = convert<bspArea>(second.at(firstId));


    if(isInRange(firstArea.x1, firstArea.x2, secondArea.x1))
    {
        
    }
}

using bspCollectinRule = rule bspCollector 
{
    // detect if next symbol is bspCollector and has the same level
    if(bspHasCollectorAsNeighboorWithLevel(getCurrentPosition(),this.level))
    {
        return true;
    } 
    return false;
} {
    // merge this and its neighbour

    bspCollector neigh = convert<bspCollector>(getSymbol(getCurrentStringId(), getCurrentPosition()+1));
   
    int iterator = neigh.areas.size(); 
    // copy to this
    while(iterator > 0)
    {
        this.areas.insert(neigh.areas.at(iterator-1));
        iterator = iterator -1;
    }
    this.level = this.level + 1;
    appendSymbol(this);
    skipSymbol();
};

using bspFinalRule = rule bspCollector 
{
    if(bspHasCollectorAsNeighboor(getCurrentPosition()) == false)
    {
        return true;
    }
    return false;
} {
    // append final structure
    appendSymbol(bspFinal(this));
};

using visualize = rule bspFinal
{
    return true;
} 
{
    collection col;
    col.insert(fillColorStyle(REDCOLOR));
    int iterator = this.finalProduct.areas.size(); 
    // copy to this
    while(iterator > 0)
    {
        bspArea area = convert<bspArea>(this.finalProduct.areas.at(iterator-1));
        appendSymbol(rectangle(point(area.x1, area.y1), point(area.x2, area.y2),col));
        iterator = iterator -1;
    }
    
};

int init()
{
    appendSymbol(bspLevel(bspArea(0.0,0.0,1024.0,1024.0), 2));
    setRandomSeed(190.0);

    //initSVG();
    
    //collection col;
    //col.insert(fillColorStyle(REDCOLOR));

    //appendSymbol(rectangle(point(0.0,0.0), point(100.0,100.0), col));
}
